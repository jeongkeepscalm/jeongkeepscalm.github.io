---
title: "개념(키워드) 정리"
description: "개념(키워드) 정리"
date: 2024-05-17
categories: [Interview, Keyword]
tags: [Interview, Keyword]
---

# HTTP
  
`TCP-IP(Transmission Control Protocol)의 4가지 특징`  
1. 연결지향 TCP 3 way handshake
  - 3 way handshake : TCP/IP 프로토콜에서 클라이언트와 서버 간 안정적인 연결을 시작하고 확인하는 방법
2. 데이터 전달 보장
3. 순서 보장
4. 신뢰할 수 있는 프로토콜

`DNS`
- Domain Name System 으로 IP 주소를 직접 기억할 필요가 없이 사람이 읽기 쉬운 문자로 변환하거나 그 반대의 작업을 수행하는 시스템

`URL`  
- Uniform Resource Identifier 의 약자로 URL 과 URN 으로 분류된다.  
- URL(locator): 리소스의 위치를 지정  
- URN(Name): 리소스에 이름을 부여

`stateful`
- 이전 상태를 기억하고 이를 통해 다음 작업을 수행하는 것  
- 항상 같은 서버가 유지되어야 한다. ( 쿠키/서버 세션 등을 사용 시 상태 유지 )

`stateless`
- 각 요청을 독립적으로 처리하는 것  
- HTTP는 무상태 프로토콜이다  
- 아무 서버나 호출해도 된다 ( 로그인이 필요없는 단순 서비스 소개 화면 )

<br/>
<hr>

# JAVA

`클래스`
- 여러 객체(인스턴스)를 생성할 수 있는 설계도

`인스턴스`
- 클래스에서 정의한 속성과 메소드를 가지고 있어 메모리에 할당된 실체

`GC(Garbage Collector)`
- JVM에 존재하며 참조하지 않는 인스턴스를 제거한다.

`객체 지향 프로그래밍(OOP: Object Oriented Programming)`  
- 데이터와 메소드를 하나의 객체에 묶는 프로그래밍 패러다임  
- 캡슐화, 상속, 다형성 등의 개념을 통해 코드의 재사용성, 유지보수성, 확장성을 향상

`절차 지향 프로그래밍`
- 실행 순서 중요
- 데이터와 해당 데이터에 대한 처리 방식이 분리

`캡슐화(Encapsulation)`  
- 클래스 내 필드/메소드를 외부로부터 숨겨 클래스 내부 데이터 조작을 방지
- 클래스 내부 코드를 변경하더라도 외부에서 알 수 없으므로 코드의 유지보수성과 확장성을 향상
- 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화이다.

`생성자`
- 객체의 초기값을 설정하며 객체 생성 시 즉시 호출

`생성자 오버로딩`
- 파라미터의 개수나 타입이 다른 생성자를 추가

`메소드 오버라이딩`
- 인터페이스의 메소드를 구현체가 재정의하는 것

`자바 메모리 구조`  
- 메소드 영역 : 클래스들의 정보 && static 변수 보관  
- 힙 영역 : new 명령어를 사용한 인스턴스가 보관되는 영역, GC가 이루어지는 주요영역  
- 스택 영역 : 메소드를 실행할 때마다 스택 프레임이 하나씩 쌓이며 메소드가 종료되면 스택프레임이 제거된다.

`Static 변수`
- 생성된 인스턴스끼리 공유되는 변수

`Static 메소드`
- 인스턴스 생성 필요없이 호출가능한 메소드

`상수(Constant)`
- 변하지 않고, 항상 일정한 값을 갖는 수

`다형성(Polymorphism)`
- 한 객체가 여러 타입의 객체로 취급될 수 있는 능력

`업/다운캐스팅(up/down Casting)`
- 부모/자식 타입으로 변경

`추상 클래스`
- 인터페이스와 같은 역할로 인스턴스 생성 불가능하고 부모타입의 껍데기 역할만 제공한다.

`객체지향 패러다임 특징`
- 추상화: 공통 속성이나 기능을 도출
- 캡슐화: 속성과 기능를 하나로 묶은 것으로 외부에서 직접 접근할 수 없도록 숨기는 것
- 상속: 상위 클래스의 속성과 기능을 하위 클래스가 물려받는 것
- 다형성: 하나의 인터페이스나 클래스를 다양한 방식으로 동작하게 하는 것

`불변 객체`
- 객체 내부의 필드가 변하지 않는 객체( final 사용 )

`스트링 풀(String Pool)`
- 자바 실행 시점에 클래스 내 문자열 리터럴을 스캔하고 존재한다면, 메모리 효율성과 성능 최적화를 위해 String 인스턴스를 생성하여 보관하는 장소
- 힙 영역 사용

`String 클래스는 왜 equals()로 값을 비교할까?`
- String 클래스 내부적으로 Object.equals() 를 오버라이딩하여 참조 값이 아닌 객체 내용 자체를 비교한다.

`String 은 왜 불변객체일까?`
- 스트링 풀에 존재하는 인스턴스의 값을 변경하면 해당 인스턴스를 참조하는 모든 문자열이 변경된다. 

`메소드 체이닝(Method Chaining)`
- 반환 값이 자기 자신(this)의 참조 주소값으로 만들어진 메소드를 활용
- 연속적으로 메소드를 호출할 수 있는 프로그래밍 기법
- 간결한 코드, 좋은 가독성

`스트링 빌더(String Builder)`  
- 문자열을 수정하거나 연산을 수행할 때 사용하는 클래스 
- String 클래스와는 다르게 가변성으로 문자열 연산 시 새 인스턴스를 생성하지 않고 기존 인스턴스를 재사용하므로 메모리 효율성이 높다.
- **반복이 많은 루프 내 문자열을 합칠 경우 사용**

`박싱/언박싱(Boxing/Unboxing)`
- 기본형 → 래퍼클래스 / 래퍼클래스 → 기본형

`리플랙션`
- 런타임에 생성자, 필드, 메소드 등의 정보를 조회/조작/호출할 수 있는 자바 API

`ENUM Type`
- 상수를 정의하여 구성
- 유효하지 않은 값 입력 방지(데이터 일관성 보장)

`내부 클래스`
- 외부 클래스와 연관성이 높으며 특정 클래스에서만 활용이 될 때 사용

`익명 클래스`  
- 클래스의 이름을 생략하고 클래스의 선언과 생성을 한번에 처리하는 클래스  
- 특정 상위 타입을 간단히 구현해서 일회성으로 사용할 때 유용

`예외 처리`
- 프로그램의 안정성과 신뢰성을 높여주는 중요한 역할
- 맞춤 예외 클래스 생성하려면 Exception 을 상속 받아야 한다. 
- Throwable
  - Exception
    - SQL Exception
    - IO Exception
    - Runtime Exception
      - NullPointoer Exception
      - IllegalArgument Exception
  - Error
    - OutOfMemoryError

`체크 예외`
- 개발자가 직접 명시적으로 처리해야 하는 예외

`언체크 예외`  
- RuntimeException 과 그 하위 예외로 컴파일러가 예외 체크를 하지 않는다.  
- throws 키워드 생략이 가능하여 생략할 경우 자동으로 예외를 던진다.

`try-with-resources`
- AutoClosable 인터페이스 구현체
- 모든 리소스가 제대로 닫히도록 보장
- try 블럭이 끝나는 즉시 close() 메소드를 호출

<br/>
<hr>

# SPRING

`객체 지향 프로그래밍(OOP)의 5가지 설계 원칙 'SOLID'`
- 단일 책임의 원칙(SRP: Single Responsibility Principle) 
  - 1 클래스 1 기능
- 개방 폐쇄 원칙(OCP: Open Closed Principle)
  - 확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다.
- 리스코프 치환 원칙(LSP: Liskov Substitution Principle)
  - 하위 타입은 상위 타입으로 교체가능하다. (다형성)
- 인터페이스 분리 원칙(ISP: Interface Segregation Principle)
  - 인터페이스를 각각 목적에 맞게 분리
- 의존 역전 원칙(DIP: Dependency Inversion Principle)
  - 구체적인 클래스에 의존하지 말고, 추상화(추상클래스/인터페이스)에 의존해라.

`ApplicationContext`  
- 스프링 컨테이너이자 인터페이스  
- 객체의 생성과 관리, 그리고 의존성 주입을 담당  
- AnnotationConfigApplicationContext > ApplicationContext(Interface) > BeanFactory(Interface)

`싱글톤 패턴` 
- 클래스의 인스턴스가 딱 한 개만 생성하도록 보장하는 디자인 패턴
- 등록된 모든 빈(Bean)을 기본적으로 싱글톤으로 생성하고 관리
- 데이터 공유 목적

`의존관계 주입`
- 생성자 주입
  - 객체 생성 시 한 번만 호출 == 불변
  - 프레임워크에 의존 x
  - 자바 언어를 살린 의존 주입 방법
- 수정자 주입
  - set 메소드를 public 으로 열어두어야 한다.
- 필드 주입
  - 외부에서 변경이 불가능해서 테스트 하기 힘들다.
- 일반 메소드 주입

`디스패처 서블릿(Dispatcher Servlet == Front Controller)`
- 클라이언트 요청 → 공통 작업 처리 → 요청에 맞는 컨트롤러

`SLF4J`
- 수 많은 로그 라이브러리를 통합한 인터페이스  
`Logback`
- SLF4J 구현한 구현체
- 스프링 부트 기본 제공

`servlet`
- 다양한 유형의 요청에 응답할 수 있는 자바 클래스
- HttpServletResponse, HttpServletRequest 사용

`HTTP 요청 메시지 전달하는 3가지 방법`
1. GET(쿼리 파라미터)
- 메시지 바디 이용
  - CONTENT-TYPE
    2. application/x-www-form-urlencoded, multipart/form-data
    3. application/json

`MVC 패턴`
- 비지니스 로직과 VIEW 렌더링 역할을 나눔

`redirect`
- 응답 → redirect에 설정된 경로로 재요청 → 응답

`Spring MVC 요청 처리 전체 흐름`
1. 서블릿 진입 (Tomcat → Spring) HttpServlet.service() → FrameworkServlet.service() (스프링 진입) → DispatcherServlet.doDispatch() (핵심 로직 시작)
2. 핸들러(컨트롤러) 조회 및 어댑터 준비 → HandlerMapping 조회 (요청 URL에 맞는 핸들러 찾기) → HandlerAdapter 조회 (핸들러를 실행할 수 있는 어댑터 찾기)
3. 비즈니스 로직 실행 → HandlerAdapter.handle() 실행 → 핸들러(Controller) 비즈니스 로직 수행 → ModelAndView 반환 (데이터와 뷰 이름 리턴)
- HTML 응답일 경우
  4. 뷰 렌더링 (HTML 응답인 경우) → ViewResolver 호출 (뷰 이름으로 실제 뷰 객체 찾기) → View 반환 → view.render() (HTML 생성 및 응답)
- JSON 응답일 경우
  4. API. 메시지 컨버터 동작 (JSON 응답) → 핸들러(Controller) 실행 중 @ResponseBody 감지 → HttpMessageConverter 동작 (객체를 JSON으로 변환 후 Body에 씀) → ModelAndView는 null 반환 → 뷰 렌더링 과정 생략하고 종료

`DispatcherServlet`
- HTTP 요청 받음 → 적절한 핸들러를 찾고 → 해당 핸들러를 실행 → 비지니스 로직 실행 (컨트롤러) → 뷰 리졸버를 사용하여 뷰를 결정 → HTTP 응답을 생성하여 반환

`PRG(Post / Redirect / Get)를 해야하는 이유`
- PRG를 하지 않을 경우 URL이 그대로 남아있으며 새로고침 시 같은 비지니스 로직을 계속 태운다.
- redirect 시 RedirectAttributes 사용

`서블릿 필터`
- HTTP 요청 → WAS → 필터체인 → 디스패처 서블릿 →  핸들러(컨트롤러)
- 필터체인
  - 필터1: 로그 남기는 필터
  - 필터2: 로그인 여부 체크하는 필터
- 내부 메소드
  - init : 서블릿 컨테이너 생성될 때 호출
  - doFilter : 모든 요청 시 호출(필터 로직 구현)
  - distory : 서블릿 컨테이너 종료될 때 호출

`스프링 인터셉터`
- HTTP 요청 → WAS → 필터체인 → 디스패처 서블릿 → 스프링 인터셉터(체인) → 핸들러(컨트롤러)
- 서블릿 필터보다 편리하고 더 정교하고 다양한 기능 지원
- 내부 메소드
  - preHandle : 컨트롤러 호출 전 호출
  - postHandle : 컨트롤러 호출 후 호출
  - afterCompletion : 뷰 렌더링 후 항상 호출

`예외처리 방법`
- HTML : 4xx, 5xx 와 같은 오류 페이지 이동
- API  : 각 오류 상황에 맞는 오류 응답을 정하고 JSON 으로 데이터 응답  
| 구분 | HandlerExceptionResolver | @ControllerAdvice (+@ExceptionHandler) |
| :---: | :---: | :---: |
| **레벨** | **Low Level**<br>(스프링 내부 인터페이스) | **High Level**<br>(개발자 친화적 어노테이션) |
| **주 사용처** | 스프링 내부 동작 제어, 레거시 코드 | **실무 비즈니스 예외 처리 (99%)** |
| **반환 타입** | `ModelAndView` (화면 중심) | `ResponseEntity`, `Object` (JSON 중심) |
| **구현 난이도** | 복잡함<br>(`HttpServletResponse` 직접 제어 필요) | 매우 쉬움<br>(메소드 작성하듯 작성) |
| **적용 범위** | 서블릿 컨테이너 레벨에 가까움 | 컨트롤러 전역 또는 패키지 단위 지정 가능 |



<br/>
<hr>

