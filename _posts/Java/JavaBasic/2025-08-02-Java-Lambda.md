---
title: "[JAVA] Lambda"
description: "[JAVA] Lambda"
date: 2025-08-02
categories: [ Java, Java Basic ]
tags: [ Java, Java Basic, kyh ]
---

### 람다

- 익명 클래스 사용의 보일러플레이트 코드를 크게 줄이고, 간결한 코드로 생산성과 가독성을 높일 수 있다.
	- 보일러플레이트 코드: 반복적으로 작성해야 하는 고정된 형식의 코드
- 대부분의 익명 클래스는 람다로 대체할 수 있다.
- 람다를 사용할 때 new 키워드를 사용하지 않지만, 람다도 익명 클래스처럼 인스턴스가 생성된다.
- 함수형 인터페이스에만 할당 가능
	- 함수형 인터페이스: 정확히 하나의 추상 메서드를 가지는 인터페이스
	- 단일 추상 메서드: SAM(Single Abstract Method)

<br>
<hr>

### 고차함수

- 함수를 인자로 받거나 함수를 반환하는 메소드
- 함수를 다루는 추상화 수준이 더 높다는 데에서 유래

```java
// 함수(람다)를 매개변수로 받음
// e.g. 
//  Function<T, R>
//  , Supplier<T>
//  , Consumer<T>
//  , Runnable, Predicate<T>
//  , UnaryOperator<T>
//  , BinaryOperator<T>
static void calculate(MyFunction function) {
  // ...
}

// 함수(람다)를 반환
static MyFunction getOperation(String operator) {
  // ...
  return (a, b) -> a + b;
}
```

<br>
<hr>

- `명령형 프로그래밍`
  - 프로그램이 수행해야 할 각 단계와 처리 과정을 상세하게 기술하여, 어떻게 결과에 도달할지를 명시한다.
- `선언적 프로그래밍` 
  - 원하는 결과나 상태를 기술하며, 그 결과를 얻기 위한 내부 처리 방식은 추상화되어 있어 개발자가 무엇을 원하는지에 집중할 수 있게 한다.
  - Lambda: 내부반복

<br>
<hr>

- 익명 클래스
  - 컴파일 시 실제로 OuterClass$1.class 와 같은 클래스 파일이 생성된다. 일반적인 클래스와 같은 방식으로 작동한다. 해당 클래스 파일을 JVM에 불러서 사용하는 과정이 필요하다.
- 람다
  - 컴파일 시점에 별도의 클래스 파일이 생성되지 않는다. 자바를 실행하는 실행 시점에 동적으로 필요한 코드를 처리한다
  - 내부적으로 invokeDynamic 을 활용하여 별도의 클래스 파일이 아닌, 런타임 시점에 동적으로 람다 인스턴스를 생성한다.

- 언제 어떤 것을 사용할까?
  - 복잡한 인터페이스 구현(메서드가 여러 개)이 필요하거나, 상태를 유지해야 하는 경우는 익명 클래스를 사용한다.
  - 간결성과 함수형 방식이 필요한 경우(함수형 인터페이스 하나만 구현)에는 람다가 훨씬 직관적이며, 코드량을 줄일 수 있다.

<br>
<hr>

### 메소드 참조

- 메서드 참조의 필요성
  - 람다에서 이미 정의된 메서드를 단순히 호출하기만 하는 경우, 메서드 참조로 더 간결하게 표현할 수 있다.
  - 코드 중복을 줄이고 가독성을 높여주며, 유지보수 측면에서도 편리하다.
  - 간결성, 가독성, 유연성, 재사용성

- 메서드 참조의 4가지 유형
  - 정적 메서드 참조: 클래스명::메서드명
  - 특정 객체의 인스턴스 메서드 참조: 객체명::메서드명
  - 생성자 참조: 클래스명::new
  - 임의 객체의 인스턴스 메서드 참조: 클래스명::메서드명
    - 클래스명으로 지정한 첫 번째 매개변수가 곧 호출 대상 객체가 된다.

<br>
<hr>

### 정리

1. 스트림(Stream)이란?
  - 자바 8부터 추가된 데이터 처리 추상화 도구로, 컬렉션/배열 등의 요소들을 일련의 단계(파이프라인)로 연결해 가공, 필터링, 집계할 수 있다. 
  - 내부 반복(forEach 등)을 지원해, "어떻게 반복할지"보다는 "무엇을 할지"에 집중하는 선언형 프로그래밍 스타일을 구현한다.
2. 중간 연산(Intermediate Operation)과 최종 연산(Terminal Operation)
  - 중간 연산: filter , map , distinct , sorted , limit 등. 스트림을 변환하거나 필터링하는 단계. 지연(Lazy) 연산이라서 실제 데이터 처리는 최종 연산을 만나기 전까지 미뤄진다.
  - 최종 연산: forEach , toList , count , min , max , reduce , collect 등. 스트림 파이프라인을 종료하며 실제 연산을 수행해 결과를 반환한다. 한 번 최종 연산을 수행하면 스트림은 소멸되므로, 재사용할 수 없다.
3. 지연 연산(Lazy Evaluation)
  - 스트림은 중간 연산 시점에 곧바로 처리하지 않고, 내부에 "어떤 연산을 할 것인지"만 저장해둔다. 최종 연산이 호출되는 순간에야 중간 연산들을 한 번에 적용하여 결과를 만든다. 덕분에 단축 평가(Short-Circuit) 같은 최적화가 가능하다. 예를 들어 findFirst() , limit() 등으로 불필요한 연산을 건너뛸 수 있다.
4. 파이프라인(pipeline)과 일괄 처리(batch) 비교
  - 모든 요소를 한 번에 처리하고, 그 결과를 모아서 다음 단계로 넘어가는 방식을 일괄 처리라고 한다. 자바 스트림은 요소 하나를 filter → 통과 시 바로 map → … → 최종 연산으로 넘기는 식의 파이프라인 방식으로 동작한다. 파이프라인 구조와 지연 연산 덕분에, 필요 이상의 연산을 줄이고 메모리 효율도 높일 수 있다.
5. 기본형 특화 스트림(IntStream, LongStream, DoubleStream)
  - 박싱/언박싱 오버헤드를 줄이고, 합계, 평균, 최솟값, 최댓값, 범위 생성 같은 숫자 처리에 특화된 메서드를제공한다.
  - 일반 스트림보다 루프가 매우 큰 상황에서 성능상 이점이 있을 수 있고, range() , rangeClosed() 를 통해 반복문 없이 손쉽게 범위를 다룰 수도 있다.
6. Collector와 Collectors
  - collect 최종 연산을 통해 스트림 결과를 리스트나 맵, 통계 정보 등 원하는 형태로 모을 수 있다. 
  - Collectors 클래스는 toList , toSet , groupingBy , partitioningBy , mapping ,averagingInt 같은 다양한 수집용 메서드를 제공한다.특히 groupingBy 나 partitioningBy 에 다운 스트림 컬렉터를 지정하면, "그룹별 합계, 평균, 최대/최솟값, 여러 형태로 다시 매핑" 등 복합적인 요구사항을 한 번에 처리할 수 있다.


- 소스코드: <https://github.com/jeongkeepscalm/java-lambda/tree/master/src> 